import subprocess
import tempfile
import re
import nest_asyncio
from guesslang import Guess
from ipykernel.kernelbase import Kernel

nest_asyncio.apply()


class metacall_jupyter(Kernel):
    """
    Defines the Jupyter Kernel declaration for MetaCall Core
    """

    implementation = "Jupyter Kernel for MetaCall Core"
    implementation_version = "0.1"
    language = "MetaCall Core"
    language_version = "0.4.12"
    language_info = {
        "name": "MetaCall Core",
        "mimetype": "text/plain",
        "file_extension": ".txt",
    }

    banner = "Wrapper Kernel for MetaCall Core Library leveraging IPython and Jupyter"

    def do_execute(  # noqa: C901
        self, code, silent, store_history=True, user_expressions=None, allow_stdin=False
    ):
        """
        Executes the User Code

        Parameters:
            code: The code to be executed
            silent: Whether to display output
            store_history:  Whether to record this code in history and increase the execution count
            user_expressions: Mapping of names to expressions to evaluate after the code has run
            allow_stdin: Whether the frontend can provide input on request

        Returns:
            send_response: Sends the execution result
        """
        if not silent:
            try:

                def split_magics(code):
                    """
                    Grabs the langage name passed in the magic and returns the magic and the code

                    Parameters:
                        code: Code to be parsed from and the magic extracted

                    Returns:
                        magics: The Language Name passed through Magic
                        code: The parsed code with the magic extracted from the same
                    """
                    code_lines = []
                    magics = []
                    lines = code.split("\n")

                    state = "magics"
                    for line in lines:
                        if state == "magics":
                            if line.startswith("%"):
                                magics.append(line.lstrip("%"))
                                continue
                            elif not line:
                                continue
                        state = "code"
                        code_lines.append(line)
                    return (magics, "\n".join(code_lines))

                def guess_code(code):
                    """
                    Guess the User Code

                    Parameters:
                        code: The code snippet whose language is to be determined

                    Returns:
                        language: The language of the code snippet detected by guesslang
                    """
                    guess = Guess()
                    language = guess.language_name(code)
                    return language

                def metacall_execute(code, extension):
                    """
                    Executes the Code passed by creating a temporary file
                    using a MetaCall Subprocess

                    Parameters:
                        code: Code to executed by the MetaCall subprocess
                        extension: The extension of the code to create a temporary file from

                    Returns:
                        logger_output: The log output generated by the subprocess
                                       after a successful execution
                    """
                    with tempfile.NamedTemporaryFile(suffix=extension) as temp:
                        temp.write(code.encode())
                        temp.flush()
                        result = subprocess.Popen(
                            ["metacall", str(temp.name)],
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                        )
                        stdout_value, stderr_value = result.communicate()
                        std_output = repr(stdout_value)
                        std_error = repr(stderr_value)
                        full_output = std_output + "\n" + std_error
                        exact_output = full_output[2:-5]
                        split_output = exact_output.split("\\n")
                        logger_output = ""
                        for item in split_output:
                            logger_output += item + "\n"

                    temp.close()
                    return logger_output

                def shell_execute(code, shcmd):
                    """
                    Executes the Shell Commands using a Subprocess

                    Parameters:
                        code: Shell Command to executed by the subprocess
                        shcmd: Configuration to call Shell Commands

                    Returns:
                        logger_output: The log output generated by the subprocess
                                       after a successful execution
                    """
                    from subprocess import run, PIPE, STDOUT

                    cmd = str(code[len(shcmd) :].lstrip())
                    exact_output = run(cmd, stdout=PIPE, stderr=STDOUT, shell=True)
                    logger_output = exact_output.stdout.decode()
                    return logger_output

                def delete_line_from_string(code):
                    """Delete the Script loading message from the execution"""
                    regex = re.compile(r"Script \(.+\) loaded correctly")
                    match = regex.search(code)
                    if match:
                        code = regex.sub("", code)
                    return code

                def trim_empty_lines(text):
                    """Trim the empty lines from the logger output for better formatting"""
                    import os

                    text = os.linesep.join([s for s in text.splitlines() if s])
                    return text

                extensions = {
                    "python": ".py",
                    "javascript": ".js",
                    # TypeScript is given a `.ts` extension because `guesslang`
                    # sometimes incorrectly identifies a JavaScript snippet as
                    # that of TypeScript.
                    "typescript": ".js",
                }

                (magics, code) = split_magics(code)
                shcmd = "!"

                if code.startswith(shcmd):
                    logger_output = shell_execute(code, shcmd)

                elif magics:
                    magic_lang = "".join(map(str, magics))
                    extension = extensions[magic_lang]
                    logger_output = metacall_execute(code, extension)

                else:
                    language = guess_code(code)
                    language = language.lower()
                    if language in extensions:
                        extension = extensions[language]
                        logger_output = metacall_execute(code, extension)

                    else:
                        logger_output = (
                            "We don't suppport "
                            + language
                            + " language, yet.\nPlease try another language or add support for "
                            + language
                            + " language.\n"
                        )

            except Exception as e:
                logger_output = str(e)

            stream_content = {
                "name": "stdout",
                "text": trim_empty_lines(delete_line_from_string(logger_output)),
            }
            self.send_response(self.iopub_socket, "stream", stream_content)

        return {
            "status": "ok",
            "execution_count": self.execution_count,
            "payload": [],
            "user_expressions": {},
        }
